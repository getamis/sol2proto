// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.

// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

package main

import (
	"bytes"
	"fmt"
	"html/template"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"github.com/ethereum/go-ethereum/accounts/abi"
	flag "github.com/spf13/pflag"

	"github.com/getamis/sol2proto/grpc"
	"github.com/getamis/sol2proto/util"
)

var (
	abiFile string
	pkgName string
)

func init() {
	flag.StringVar(&abiFile, "abi", "", "ABI file generated by solc")
	flag.StringVar(&pkgName, "pkg", "p", "go package name for the generated proto")
}

func main() {
	flag.Parse()

	abiString, err := ioutil.ReadFile(abiFile)
	if err != nil {
		fmt.Printf("Failed to read input ABI: %v\n", err)
		os.Exit(-1)
	}

	contractAbi, err := abi.JSON(bytes.NewReader(abiString))
	if err != nil {
		fmt.Printf("Failed to parse contract ABI: %v\n", err)
		os.Exit(-1)
	}

	pkg := pkgName
	if pkgName == "" {
		pkg = strings.ToLower(strings.TrimSuffix(filepath.Base(abiFile), filepath.Ext(filepath.Base(abiFile))))
	}
	srvName := util.ToCamelCase(strings.TrimSuffix(filepath.Base(abiFile), filepath.Ext(filepath.Base(abiFile))))
	service := grpc.Service{
		Package:  pkg,
		Name:     srvName,
		Messages: make(map[string]grpc.Message),
	}

	service.Messages[grpc.EmptyReq.Name] = grpc.EmptyReq
	service.Messages[grpc.TransactOptsReq.Name] = grpc.TransactOptsReq
	service.Messages[grpc.TransactionResp.Name] = grpc.TransactionResp

	for _, f := range contractAbi.Methods {
		var inputArgs []grpc.Argument
		var outputArgs []grpc.Argument
		method := grpc.Method{
			Const: f.Const,
			Name:  f.Name,
		}

		// If it is not a const method, we need to provide
		// more transaction options to send transactions.
		if !f.Const {
			inputArgs = append(inputArgs, grpc.Argument{
				Name:    "opts",
				Type:    grpc.TransactOptsReq.Name,
				IsSlice: false,
			})
		}

		for _, input := range f.Inputs {
			arg := grpc.ToGrpcArgument(input)
			method.Inputs = append(method.Inputs, arg)
			inputArgs = append(inputArgs, arg)
		}

		for _, output := range f.Outputs {
			arg := grpc.ToGrpcArgument(output)
			method.Outputs = append(method.Outputs, arg)
			outputArgs = append(outputArgs, arg)
		}

		if len(inputArgs) > 0 {
			inMsg := grpc.ToMessage(method.RequestName(), inputArgs)
			service.Messages[inMsg.Name] = inMsg
		}

		if len(outputArgs) > 0 {
			outMsg := grpc.ToMessage(method.ResponseName(), outputArgs)
			service.Messages[outMsg.Name] = outMsg
		}
		service.Methods = append(service.Methods, method)
	}

	for i, ev := range contractAbi.Events {
		method := grpc.Method{}

		if ev.Anonymous {
			method.Name = fmt.Sprintf("onEvent%s", i)
		} else {
			method.Name = "on" + ev.Name
		}

		for _, in := range ev.Inputs {
			arg := grpc.ToGrpcArgument(in)
			method.Inputs = append(method.Inputs, arg)
		}

		if len(method.Inputs) > 0 {
			inMsg := grpc.ToMessage(method.RequestName(), method.Inputs)
			service.Messages[inMsg.Name] = inMsg
		}

		service.Events = append(service.Events, method)
	}

	grpcTemplate, err := template.New("proto").Parse(grpc.ServiceTemplate)
	if err != nil {
		fmt.Printf("Failed to parse template: %v\n", err)
		os.Exit(-1)
	}

	err = grpcTemplate.Execute(os.Stdout, service)
	if err != nil {
		fmt.Printf("Failed to render template: %v\n", err)
		os.Exit(-1)
	}
}
